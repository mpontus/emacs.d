# -*- org-cappendontent-indentation: 0; org-src-preserve-indentation: t; -*-
#+TITLE: Emacs Init File
#+STARTUP: showall
#+PROPERTY: header-args :tangle no :noweb yes :noweb-ref runtime-configuration :results silent

* Installation

Execute the code block below to bootstrap the ~init.el~ file.

#+BEGIN_SRC emacs-lisp :tangle yes :noweb-ref none
;; This is the only source block in the file that gets tangled. All
;; other source blocks will be embedded in the codition below using
;; noweb references.
;;
;; Special properties at the top of this file assigns default
;; reference name to every block and excludes them from tangling. This
;; block overrides this configuraiton using header props.
;;
;; The condition below evaluates the content of all other blocks when
;; init.el is newer than init.el, otherwise it reinitializes init.el
;; from init.org and evaulates it after init.el gets updated.
(if (file-newer-than-file-p (locate-user-emacs-file "init.org")
			    (locate-user-emacs-file "init.el"))
    (let ((debug-on-quit t) (debug-on-error t))
      (org-babel-load-file (locate-user-emacs-file "init.org"))
      ;; Byte compile the file separately so that the macros will be
      ;; set up by the time byte-compilation happens
      (byte-compile-file (locate-user-emacs-file "init.el")))
  <<runtime-configuration>>)
#+END_SRC

** Customization

Customization is another way by which emacs configuration can be
adjusted. 

#+begin_src emacs-lisp
;; Extract customization into a separate file to prevent it from being
;; overriden when ~init.el~ is rebuilt.
(setq custom-file (locate-user-emacs-file "custom.el"))

;; Save custom theme customization before exiting emacs
(use-package cus-theme :ensure nil
  :commands custom-theme-save
  :hook (kill-emacs . custom-theme-save)
  ;; Don't ask for confirmation when installing themes
  :config (setq custom-safe-themes t))
#+end_src

** Package Manager

Setup builtin package manager.

#+BEGIN_SRC emacs-lisp
(require 'package)

(setq package-archives
    '(("org" . "https://orgmode.org/elpa/")
    ("melpa" . "https://melpa.org/packages/")
    ("gnu" . "http://elpa.gnu.org/packages/")))

(ignore-errors
    (package-initialize 'no-activate)
    (package-refresh-contents 'async))
#+END_SRC

*** Use Package

Enable more convenient configuration for external packages.

#+BEGIN_SRC emacs-lisp
(package-install 'use-package)
(setq use-package-always-ensure t)
#+END_SRC

Configure ~use-package~ to always download missing packages.

#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)
#+END_SRC

Initialize ~bind-key~ because some packages will complain about ~personal-keybindings~ being undefined.

#+BEGIN_SRC emacs-lisp
(use-package bind-key)
#+END_SRC

*** Quelpa

Quelpa helps install packages which have yet to be published to melpa.

I use it to install my own packages.

#+BEGIN_SRC emacs-lisp
(use-package quelpa)
#+END_SRC

Install quelpa support for use-package:

#+BEGIN_SRC emacs-lisp
(eval-and-compile
    (use-package quelpa-use-package
    :config (quelpa-use-package-activate-advice)))
#+END_SRC

*** El-Get

To fetch scripts from EmacsWiki

#+begin_src emacs-lisp
(use-package el-get
  :ensure t)

(use-package use-package-el-get
  :ensure t
  :config (use-package-el-get-setup))
#+end_src

** Maintenance

*** Validation

Check syntax before save. Helps avoid unbalanced parentheses!

#+begin_src emacs-lisp
(defun init-org-after-save-hook ()
    (org-babel-map-src-blocks nil
    (save-restriction
      (narrow-to-region (goto-char beg-body) end-body)
      (with-syntax-table emacs-lisp-mode-syntax-table
	(condition-case err
	    (while (not (eobp))
	      (and (zerop (skip-chars-forward "\s\t\r\n"))
		   (null (forward-comment 1))
		   (read (current-buffer))))
	  (t (error "%s" (error-message-string err)))))))
  (message "ðŸ˜Š Syntax check complete!"))

(define-minor-mode init-org-syntax-check-mode
  "Validate syntax of init.org src blocks"
  :global t
  (if init-org-syntax-check-mode
      (add-hook 'before-save-hook
		#'init-org-syntax-check
		nil
		'local)
    (remove-hook 'before-save-hook
		 #'init-org-syntax-check
		 'local)))
#+end_src


Evaluate changed source blocks on save


#+begin_src emacs-lisp
  (defvar-local org-babel--unhandled-changes nil)

  (defun org-babel-record-change (beg end len)
    (setq org-babel--unhandled-changes
          (seq-sort
           (lambda (a b) (< (car a) (car b)))
           (cons (cons (copy-marker beg)
                       (copy-marker end))
                 org-babel--unhandled-changes)))
    ;; (mapcar (lambda (m) (cons (marker-position (car m))
    ;; 			    (marker-position (cdr m))))
    ;; 	  org-babel--unhandled-changes)
    )

  ;; (let (org-babel--unhandled-changes)
  ;;   (org-babel-record-change 5 6)
  ;;   (org-babel-record-change 7 8) 
  ;;   (org-babel-record-change 3 4)
  ;;   (org-babel-record-change 1 2)
  ;;   (org-babel-record-change 9 10))


  (defun org-babel-block-changed-p (beg end)
    (let ((changes org-babel--unhandled-changes))
      (while (if-let ((region (car changes)))
                 (and (>= beg (cdr region))
                      (pop changes))))
      (if (not (null changes))
          (> end (caar changes))
        (setq org-babel--unhandled-changes nil))))

  (defun org-babel-execute-on-save ()
    (org-babel-map-src-blocks nil
      (when (org-babel-block-changed-p beg-body end-body)
        (org-babel-execute-src-block))))

  (define-minor-mode org-babel-execute-on-save-mode
    "Validate syntax of init.org src blocks"
    :global t
    (if org-babel-execute-on-save-mode
        (progn
          (add-hook 'before-save-hook
                    #'org-babel-execute-on-save nil t)
          (add-hook 'after-change-functions
                    #'org-babel-record-change nil t))
      (remove-hook 'before-save-hook
                   #'org-babel-execute-change t)
      (remove-hook 'after-change-functions
                #'org-babel-record-change t)))
#+end_src

*** Keybindings

#+begin_src emacs-lisp
(use-package major-mode-hydra
  :ensure t
  :bind ("M-SPC" . #'major-mode-hydra))

(use-package pretty-hydra
  :ensure t
  :init (require 'pretty-hydra))
#+end_src

#+begin_src emacs-lisp
(defun find-init-org-file ()
  "Open init.org from user directory"
    (interactive
    (find-file-noselect
     (locate-user-emacs-file "init.org"))))

(defhydra hydra-init-org (global-map "C-c")
    "init.org"
    ("i" find-init-org-file :exit t))
#+end_src

Convenient macro for setting up new keybindings.

#+begin_src emacs-lisp
(use-package general)
#+end_src

Get an overview of current keybindings.

#+begin_src emacs-lisp
(use-package buttons
    :bind (("<f1>K" . buttons-display)))
#+end_src

Find an unused keybinding.

#+begin_src emacs-lisp
(use-package free-keys :bind ("<f1>B" . free-keys))
#+end_src

* General
** Emacs
*** Y-or-n prompts

** Appearance
#+begin_src emacs-lisp
(tool-bar-mode -1)
(scroll-bar-mode -1)
;; Hide menu-bar unless on Mac OS X where it doesn't take away any real estate
(unless (eq window-system 'mac)
    (menu-bar-mode -1))
#+end_src

*** Themes

#+begin_src emacs-lisp
(use-package counsel
  :bind
  (("C-c t" . #'counsel-load-theme)
   ([remap apropos] . #'counsel-apropos)))
#+end_src

Load theme with the following face

#+begin_src emacs-lisp
(defun theme-get-face (theme face)
  (let ((library-file (locate-library (format "%s-theme" theme)))
	result)
    (letf (((symbol-function 'custom-theme-set-faces)
	    (lambda (theme &rest args)
	      (setq result (assoc face args)))))
      (and library-file (load library-file)))
    result))

(defun counsel-load-theme-with-face (face)
  (interactive
   (let ((default (get-text-property (point) 'face)))
     (unless (symbolp default) (setq default nil))
     (list (read-face-name "Face: " default))))
  (ivy-read "Load custom theme: "
            (mapcar 'symbol-name (custom-available-themes))
	    :predicate
	    (lambda (theme) (theme-get-face theme face))
            :action #'counsel-load-theme-action
            :caller 'counsel-load-theme))
#+end_src


*** Mode line

#+begin_src emacs-lisp
(use-package telephone-line
  :config
  (telephone-line-mode 1))
#+end_src

** Package management

#+begin_src emacs-lisp
(use-package package
  :bind (("C-c p" . #'list-packages)))

;; Provide better alternative to `list-packages`
(use-package paradox
  :config (paradox-enable))

;; Discover emacsmirror packages
(use-package epkg
  :bind ("C-c e" . #'epkg-list-packages))
#+end_src

** Window layout

#+begin_src emacs-lisp
(setq display-buffer-alist '(("`\\*Warnings\\*$" display-buffer-other-window)))

(defhydra hydra-windows (global-map "C-c")
  "windows"
  ("C-/" (progn (winner-undo) (setq this-command 'winner-undo)) "undo")
  ("C-?" #'winner-redo "redo"))

(add-to-list 'display-buffer-alist
	     '("^\\*compilation\\*$" ;; compilation-mode
	       (display-buffer-reuse-window
		;; display-buffer-below-selected
		)))

#+end_src

*** Fit window to buffer

#+begin_src emacs-lisp
(defhydra+ hydra-windows ()
  "windows"
  ("_" #'fit-window-to-buffer "fit")
  ("=" #'balance-windows "balance")
  ("-" #'shrink-window "shrink")
  ("+" #'enlarge-window "enlarge"))
#+end_src

*** Dedicated windows

#+begin_src emacs-lisp
(defun toggle-window-dedicated-p (&optional window)
    (interactive (list (selected-window)))
    (set-window-dedicated-p window (not (window-dedicated-p window)))
    (message "Window %s dedicated"
    (if (window-dedicated-p window) "is" "is not")))

(defhydra+ hydra-windows ()
  ("." #'toggle-window-dedicated-p
   (propertize "dedicated" 'face
	       (if (window-dedicated-p)
		   'transient-active-infix
		 'transient-inactive-value))
   :exit t))
#+end_src

*** Sidebar

Install treemacs

#+begin_src emacs-lisp
(use-package treemacs)
#+end_src

** Buffer management
Set up some easily accissible keybindings for buffer management

#+begin_src emacs-lisp
(global-set-key (kbd "C-c C-q") #'quit-window)
#+end_src

Quick access to buffer list

#+begin_src emacs-lisp
(global-set-key (kbd "C-c C-b") 'ibuffer-other-window)
#+end_src

** Text manipulation

*** Filter lines
#+begin_src emacs-lisp
(use-package hide-lines
  :ensure t)
#+end_src

#+begin_src emacs-lisp
(use-package hydra
  :bind
  ("C-c h" . #'hydra-hide-lines/body)
  :config
  (defhydra hydra-hide-lines (:exit t)
    "hide-lines"
    ("m" #'hide-lines-matching "matching")
    ("n" #'hide-lines-not-matching "not matching")
    ("a"  #'hide-lines-show-all "show all" :exit t)))
#+end_src

** Better defaults

Adjust some minor annoyances in default emacs configuration.

#+BEGIN_SRC emacs-lisp
;; Answer confirmation dialogs with a single key
(defalias 'yes-or-no-p 'y-or-n-p)

;; Better naming style for conflicting buffers
(setq uniquify-buffer-name-style 'reverse)

;; Enable persistent minibuffer history
(savehist-mode 1)

;; Save clipboard contents to kill ring instead of discarding them
(setq save-interprogram-paste-before-kill t)

;; Move backups and auto-save files to home directory to avoid cluttering work dir
(setq backup-directory-alist
    `((".*" . ,(expand-file-name "backups" user-emacs-directory))))
(setq auto-save-file-name-transforms
    `((".*" ,(expand-file-name "backups" user-emacs-directory) t)))

;; Replace selection when region is active during `yank'
(delete-selection-mode +1)

;; Disable ring bell on `keyboard-quit` (<C-g>)
(setq ring-bell-function 'ignore)

;; Disable electric-indent-mode by default
(electric-indent-mode -1)

;; Make find-file case-insensitive
(setq read-file-name-completion-ignore-case t)

;; Increase history length
(setq history-length 8000)

;; Backspace key is relatively difficult to access. For backward deletion I use <kbd>C-h</kbd> instead.
;; In every situation where I want to use <backspace> I want to be able to use <C-h> instead.
(global-set-key (kbd "C-h") 'backward-delete-char)

;; I haven't been able to figure out how to translate these combinations
(global-set-key (kbd "M-h") 'backward-kill-word)
(global-set-key (kbd "C-M-h") 'backward-kill-sexp)

;; Make buffer names more readable
(setq uniquify-buffer-name-style 'forward)

;; Save buffer position between sessoins.
(save-place-mode 1)

;; Load from the source if its more fresh than the compiled code.
(setq load-prefer-newer t)

;; Highlight matching paren under cursor
(show-paren-mode 1)

;; Indent with spaces not tabs.
(setq indent-tabs-mode nil)

;;End the file with a blank line.
(setq require-final-newline t)
#+end_src

** Emacs Server

Make it possible to connect to the running emacs instance using ~emacsclient~.

#+begin_src emacs-lisp
(with-eval-after-load 'server
    (when (or (not (server-running-p))
    (and (y-or-n-p "Emacs server already running. Reconnect?")
    (server-force-delete)))
    (server-start t)))
#+end_src

When a client connects, bring it up above other programs.

#+begin_src emacs-lisp
(add-hook 'server-switch-hook #'raise-frame)
#+end_src

** Global find file history

Find-file is my primary means for navigating between files, although not the only one.

Because of this, not every file ends up in file-find-history which I'm used to rely on for opening previously accessed files.

Following package adds every opened file, whichever method was used to open it, into ~file-name-history~ used by find-file.

#+BEGIN_SRC emacs-lisp
(quelpa '(find-file-global-history
    :repo "mpontus/find-file-global-history.el"
    :fetcher github))

(find-file-global-history-mode 1)
#+END_SRC

** Yank entire buffer

I often need to copy contents of the entire buffer somewhere else. This shortcut helps with that.

#+BEGIN_SRC emacs-lisp
(defun yank-entire-buffer ()
    (interactive)
    (kill-ring-save (point-min) (point-max)))

(global-set-key (kbd "C-c M-w") 'yank-entire-buffer)
#+END_SRC

** Apparance

Change default emacs appearance

#+BEGIN_SRC emacs-lisp
(set-frame-font "Fira Code-12" 'keep-size t)

;; Start emacs in fullscreen
(setq initial-frame-alist '((fullscreen . maximized)))
#+end_src

Highlight buffer changes

#+begin_src emacs-lisp
(use-package volatile-highlights
  :ensure t
  :config (volatile-highlights-mode t))
#+end_src


Make it easy to adjust text scale in all windows

#+begin_src emacs-lisp
(use-package default-text-scale
    :config (default-text-scale-mode t))
#+end_src

Highlight current line:

#+BEGIN_SRC emacs-lisp
;; Not using global-hl-line-mode because it would could not be
;; disabled on per-mode basis
(add-hook 'text-mode-hook 'hl-line-mode)
(add-hook 'prog-mode-hook 'hl-line-mode)
#+END_SRC

*** Line numbers

Show line numbers in programming modes:

#+BEGIN_SRC emacs-lisp
(defun setup-line-numbers ()
    ;; Use native line-numbers available in Emacs 26+
    (setq-local display-line-numbers t)
    ;; Disable line wrap when line numbers are shown
    (setq-local truncate-lines t))

(add-hook 'prog-mode-hook 'setup-line-numbers)
#+END_SRC

** Windows
*** Navigation

Switch between windows with M-<n>:

#+BEGIN_SRC emacs-lisp
(use-package window-number
    :quelpa (window-number :fetcher github :repo "mpontus/window-number.el")
    :config (window-number-mode))
#+END_SRC

Winner mode provides undo history for window configuration.

#+BEGIN_SRC emacs-lisp
(winner-mode 1)
(global-set-key (kbd "C-c C-/") 'winner-undo)
(global-set-key (kbd "C-c C-?") 'winner-redo)
#+END_SRC

It's easier to use Super+ESC to switch between frames on HHKB:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<s-escape>") 'other-frame)
#+END_SRC

*** Layout

How windows are arranged within a frame.

#+begin_src emacs-lisp
;; (setq split-width-threshold 74)
(setq split-width-threshold (* 2 fill-column))
(setq split-height-threshold 20)

(defun split-window-sensibly-horizontally (&optional window)
  "Like `split-window-sensibly' but prefer horizontal splits"
  (or (let ((split-height-threshold most-positive-fixnum))
	(split-window-sensibly window))
      (split-window-sensibly window)))

(setq split-window-preferred-function #'split-window-sensibly-horizontally)
#+end_src

** Editing
*** Artist Mode

Useful in editing hydras

#+begin_src emacs-lisp
;; Bind `artist-mode' close near rectangle commands
(global-set-key (kbd "C-x r a") 'artist-mode)
#+end_src

*** Execute Command on Save

#+begin_src emacs-lisp
(use-package firestarter
  :init ;; Make firestarter a safe local variable
  (put 'firestarter 'safe-local-variable 'identity)
  :config
  (firestarter-mode t))
#+end_src

** Undo Tree

The main point of emacs undo implementation is that it preserves all history even if you go back a couple of steps and introduce new changes.

This feature can help if something goes wrong, but otherwise complicates unnecessarily undo-redo workflow by making it non-linear.

Undo tree's approach keeps the basic workflow simple, while saving all of the undo information which can be accessed when necessary (<kbd>C-x u</kbd>).

#+BEGIN_SRC emacs-lisp
(package-install 'undo-tree)
(global-undo-tree-mode 1)

(global-set-key (kbd "C-/") 'undo-tree-undo)
(global-set-key (kbd "C-?") 'undo-tree-redo)
(global-set-key (kbd "C-x u") 'undo-tree-visualize)

;; Save undo history between sessions
(setq-default undo-tree-auto-save-history t)
(setq-default undo-tree-history-directory-alist
    '(("." . "~/.emacs.d/undo-tree/")))

;; I had this set at some point. I don't remember why.
;; (setcdr undo-tree-map nil)
#+END_SRC

** Multiple Cursors

Multiple cursors is like macro which allows you to observe and adjust results during recording.

Entry point is <kbd>C-c m</kbd>

#+BEGIN_SRC emacs-lisp
(package-install 'multiple-cursors)

(global-set-key (kbd "C->") 'mc/mark-more-like-this-extended)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-M->") 'mc/mark-all-like-this)
#+END_SRC

** Subword Mode

=subword-mode= enables emacs to treat each part of camel-cased experession as a separate word.

#+BEGIN_SRC emacs-lisp
(global-subword-mode 1)
#+END_SRC

** Editorconfig

Add support for .editorconfig files to infer per-project code style settings.

#+BEGIN_SRC emacs-lisp
(package-install 'editorconfig)

(editorconfig-mode 1)
#+END_SRC

** File Management

Sort by directories first in Dired listing:

#+BEGIN_SRC emacs-lisp
(use-package ls-lisp
    :ensure nil
    :config
    (setq ls-lisp-dirs-first t)
    ;; Force dired to use emacs-lisp ls implementation
    (setq ls-lisp-use-insert-directory-program nil))
#+END_SRC

Dired+ enhances dired functionality with some useful commands.

Namely, I use it to perform search-and-replace on filenames thanks to diredp-insert-subdirs-recursive.

#+BEGIN_SRC emacs-lisp
(quelpa '(dired+ :fetcher github :repo "emacsmirror/dired-plus"))
#+END_SRC

Disable dired confirmation about recursively copying directories:

#+BEGIN_SRC emacs-lisp
(setq-default dired-recursive-copies 'always)
#+END_SRC

** GPG Support

Make EasyPG query pass phrase using minibuffer:

#+BEGIN_SRC emacs-lisp
(setq epa-pinentry-mode 'loopback)
#+END_SRC

** Custom files

Additional configuraiton not inluded in this file is stored in [[./custom.el]]

#+BEGIN_SRC emacs-lisp
  (let ((custom-file (expand-file-name "custom.el" user-emacs-directory)))
    (unless (file-exists-p custom-file)
      (write-region "" nil custom-file))
    (load-file custom-file))
#+END_SRC

Passwords and authentication credentials are stored in [[./secrets.el.gpg]]

#+BEGIN_SRC emacs-lisp
(let ((secrets-file (expand-file-name "secrets.el.gpg" user-emacs-directory)))
    (when (file-exists-p secrets-file)
    (load-file secrets-file)))
#+END_SRC

** Secrets
#+begin_src emacs-lisp
(let ((secrets-file (locate-user-emacs-file "secrets.el.gpg")))
  (when (file-exists-p secrets-file)
    (load secrets-file 'noerror)))
#+end_src
** Buffer editing (buffer contents)

*** Revert buffer command

#+begin_src emacs-lisp
(global-set-key (kbd "C-c v") 'revert-buffer)
#+end_src
    
*** Swiper

Replace Isearch with Swiper, but not inside the minibuffer.

#+begin_src emacs-lisp
(define-minor-mode swiper-mode
  "Remap isearch keybindings with swiper"
  :keymap
  '(([remap isearch-forward] . swiper)
    ([remap isearch-backward] . swiper-backward)
    ;; ([remap isearch-forward] . swiper-isearch)
    ;; ([remap isearch-backward] . swiper-isearch-backward)
    ;; ([remap isearch-forward-regexp] . swiper)
    ;; ([remap isearch-backward-regexp] . swiper-backward)
    )
  :global t)

(use-package swiper
:config (swiper-mode))
#+end_src

** Scratch Buffer

Use ~text-mode~ as a default major mode for scratch buffers

#+begin_src emacs-lisp
(setq initial-major-mode #'text-mode)
#+end_src

Popup scratch buffers with different major modes

#+begin_src emacs-lisp
(defun scratch-buffer-p (&optional buffer)
  (with-current-buffer (or buffer (current-buffer))
    (equal (string-remove-suffix "-mode" (symbol-name major-mode))
	   (string-trim (buffer-name) "\\*" "\\*"))))

(use-package scratch
  :bind ("C-c s" . scratch)
  :config
  (setq persistent-scratch-scratch-buffer-p-function #'scratch-buffer-p)
  ;; (add-to-list 'popper-reference-buffers #'scratch-buffer-p)
  (add-to-list 'display-buffer-alist (cons (lambda (buffer action) (scratch-buffer-p buffer))
					   '(display-buffer-in-side-window))))
#+end_src

Save scratch buffer contents between sessions

#+begin_src emacs-lisp
(defun persistent-scratch-set-local-save-file ()
  (let* ((dir (locate-user-emacs-file ".scratch-buffers"))
	 (path (expand-file-name (buffer-name) dir)))
    (unless (file-directory-p dir) (make-directory dir))
    (setq-local persistent-scratch-save-file path)))

(defun persistent-scratch-restore-save-file ()
  (persistent-scratch-restore persistent-scratch-save-file))

(use-package persistent-scratch
  :hook
  (scratch-create-buffer . persistent-scratch-mode)
  (persistent-scratch-mode . persistent-scratch-set-local-save-file)
  :config
  (add-hook 'persistent-scratch-mode-hook
	    #'persistent-scratch-restore-save-file
	    20))
#+end_src

** Minibuffer 

Minibuffer is a panel at the bottom of emacs window (frame);

#+begin_src emacs-lisp
;; Enable recursive minibuffers.
(setq enable-recursive-minibuffers t)

;; (global-set-key [remap keyboard-quit] #'top-level)

;; Do not allow the cursor in the minibuffer prompt
(setq minibuffer-prompt-properties
      '(read-only t cursor-intangible t face minibuffer-prompt))
(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

;; Change prompt for src_emacs-lisp[:exports code]{completing-read-multiple}.
(defun crm-indicator (args)
  (cons (concat "[CRM] " (car args)) (cdr args)))
(advice-add #'completing-read-multiple :filter-args #'crm-indicator)
#+end_src

*** Completion Styles

I'm using default completing read

#+begin_src emacs-lisp
;; Add ~initials~ to default completion styles.
;; Enabling this will complete "tdoe" to "toggle-debug-on-error".
(add-to-list 'completion-styles 'initials 'append)
#+end_src

*** Minibuffer Completion

#+begin_src emacs-lisp
;; Install ivy with some extensions.
(use-package ivy
  :bind ("C-c r" . ivy-resume)
  :config
  (ivy-mode 1)
  (define-key ivy-minibuffer-map (kbd "C-c C-c")
    #'ivy-restrict-to-matches))

;; Display additional information alongside completion candidates.
(use-package ivy-rich
  :config
  (ivy-rich-mode 1)
  (setcdr (assq t ivy-format-functions-alist)
	  #'ivy-format-function-line))

(use-package all-the-icons-ivy
  :config
  (all-the-icons-ivy-setup))

(use-package all-the-icons-ivy-rich
  :config
  (all-the-icons-ivy-rich-mode 1))
#+end_src

Add various counsel commands:

#+begin_src emacs-lisp
(use-package counsel
  :bind
  (:map counsel-mode-map
	([remap execute-extended-command] . counsel-M-x))
  ("C-c a" . #'counsel-ag)
  :config
  (counsel-mode 1)
  (setq counsel-mode-override-describe-bindings t))
#+end_src

Swiper Keybindings:

- S-SPC: restrict candidates

** Code Editing
*** Buffer completion


Configure company-mode

#+BEGIN_SRC emacs-lisp
(use-package company
    :config
    (define-key company-mode-map (kbd "TAB") #'company-indent-or-complete-common))
#+END_SRC

*** Language Server Protocol

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode)
#+END_SRC


** Help


This section provides help with emacs.

- accessing documentation
- changing configuration
- debugging

#+begin_src emacs-lisp
;; Install help-mode extensions by Drew Adams
(use-package help+
  :quelpa (help+ :fetcher github  "emacsmirror/help-plus#405d525"))
#+end_src


** Keybindings

*** Hydra

Install hydra

#+begin_src emacs-lisp
(use-package hydra
  :config (setq ahs-hydra-display-legend t))
#+end_src

Experimenting with this package

#+begin_src emacs-lisp
(use-package symbol-navigation-hydra
  :after (hydra multiple-cursors auto-highlight-symbol)
  :bind ("C-c C-SPC" . symbol-navigation-hydra-engage-hydra))

(use-package auto-highlight-symbol
  :config
  (setq ahs-highlight-all-windows nil
	ahs-highlight-upon-window-switch nil
	ahs-idle-interval 999999999.0
	ahs-case-fold-search nil
	ahs-default-range 'ahs-range-whole-buffer
	ahs-inhibit-face-list (delete 'font-lock-string-face ahs-inhibit-face-list)
	ahs-inhibit-face-list (delete 'font-lock-doc-face ahs-inhibit-face-list)))
#+end_src
** Tramp

#+begin_src emacs-lisp
(use-package tramp
  :config
  (setq tramp-ssh-controlmaster-options "-o ControlMaster=auto -o ControlPath='tramp.%%C' -o ControlPersist=600")
  ;; Read .dir-locals over SSH
  (setq enable-remote-dir-locals t))

#+end_src
* Elisp


** Documentation

#+begin_src emacs-lisp
(use-package apropos
  :ensure nil
  :bind
  ("C-c a" . #'apropos))
#+end_src

Configure eldoc

#+begin_src emacs-lisp
(use-package eldoc
  :hook minibuffer-setup-hook
  :init
  (global-eldoc-mode +1)
  (eldoc-add-command 'paredit-backward-delete
		     'paredit-kill
		     'paredit-newline
		     'newline
		     'open-line
		     'hydra-paredit/paredit-kill-and-exit))

(use-package eldoc-overlay
  :hook minibuffer-setup-hook
  :config (setq eldoc-overlay-enable-in-minibuffer t))

#+end_src

Show docstring in a modal window

#+begin_src emacs-lisp
(defun eval-last-expression ()
  (interactive)
  (eval-expression
   (read (car read-expression-history))))

(global-set-key (kbd "<f12>") #'eval-last-expression)
#+end_src

*** Exec Path From Shell

    Emacs must infer $PATH from the shell configuration.

    #+BEGIN_SRC emacs-lisp
    (package-install 'exec-path-from-shell)

    (exec-path-from-shell-initialize)
    #+END_SRC

Enable a shortcut to easily bring-up a console

#+begin_src emacs-lisp
(use-package eshell-toggle 
  :bind ("C-'" . #'eshell-toggle))
#+end_src

* Org Mode

Its what this config is built with

#+BEGIN_SRC emacs-lisp
(use-package org
  ;; Always install latest org-mode from the repo
  :ensure t)
#+END_SRC

Indentation with tabs breaks tags alignment.

#+BEGIN_SRC emacs-lisp
(defun disable-indent-tabs-mode ()
  (setq indent-tabs-mode nil))

(with-eval-after-load 'org
  (add-hook 'org-mode-hook #'disable-indent-tabs-mode))
#+END_SRC

Buffer contents

#+begin_src emacs-lisp
(use-package visual-fill-column
  :ensure t)

(use-package org
  :config
  (add-hook 'org-mode-hook #'visual-fill-column-mode)
  (add-hook 'org-mode-hook #'toggle-truncate-lines)
  (add-hook 'org-mode-hook #'toggle-word-wrap))
#+end_src


** Org Babel

Configure editing source block files

#+begin_src emacs-lisp
;; Open indirect buffer in other window
(setq org-src-window-setup 'same-window)
#+end_src

Configure keybindings to open results in dedicated buffer

#+begin_src emacs-lisp

(defun org-view-narrow-to-block ()
  (interactive)
  (unless (looking-at org-babel-result-regexp)
    (goto-char (line-beginning-position 2))
    (org-backward-element))
  (save-match-data
    (re-search-forward org-block-regexp)
    (narrow-to-region (match-beginning 4) (match-end 4)))
  (goto-char (point-min)))

(defun org-view-indirect-buffer ()
  (interactive)
  (when-let ((buffer (get-buffer "*View*")))
    (kill-buffer-if-not-modified buffer))
  (with-current-buffer
      (clone-indirect-buffer "*View*" nil)
    (display-buffer-use-some-window (current-buffer) '())
    ;; (pop-to-buffer (current-buffer))
    (view-mode-enter nil 'kill-buffer)
    (org-view-narrow-to-block)))

(with-eval-after-load 'org
  (define-key org-mode-map (kbd "C-c C-v")
    #'org-view-indirect-buffer))
#+end_src

** Keybindings

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
    ;; Add aligned tag with C-c C-g
    (define-key org-mode-map (kbd "C-c C-g") 'org-set-tags)
    ;; Move subheadings/list-items up and down with M-p/M-n
    (define-key org-mode-map (kbd "M-p") 'org-metaup)
    (define-key org-mode-map (kbd "M-n") 'org-metadown))
#+END_SRC

** Shell

Enable shell source blocks

#+begin_src emacs-lisp
(org-babel-do-load-languages
    'org-babel-load-languages
    '((shell . t)))
#+end_src

** REST client

Install restclient executor to test HTTP queries in org-mode file

#+BEGIN_SRC emacs-lisp
(use-package ob-restclient
    :config
    (org-babel-do-load-languages
    'org-babel-load-languages
    '((restclient . t))))
#+END_SRC

** HTTP client

Install restclient executor to test HTTP queries in org-mode file

#+BEGIN_SRC emacs-lisp
(use-package ob-http
    :config
    (org-babel-do-load-languages
    'org-babel-load-languages
    '((http . t))))
#+END_SRC

* Anki

I save notes in org files and export them as Anki decks to be able to review them easily later on.

#+BEGIN_SRC emacs-lisp
(use-package org-anki :quelpa
    (org-anki :fetcher "github" :repo "mpontus/org-anki"))
#+END_SRC

* Git

Configuration for Version Control tools

#+begin_src emacs-lisp
(pretty-hydra-define hydra-toggle
  (global-map "C-c" :color red)
  ("Toggle"
   (("f" auto-fill-mode "auto-fill-mode" :color blue)
    ("w" whitespace-mode "whitespace-mode" :color blue)
    ("e" toggle-debug-on-error "debug-on-error" :color blue)
    ("q" toggle-debug-on-quit "quit" :color blue))))

(pretty-hydra-define hydra-magit ()
  ("Magit"
   (("g" magit-status "status" :exit t)
    ("c" magit-commit-create "commit" :exit t))))

(pretty-hydra-define hydra-git-gutter ()
  ("Hunk"
   (("n" git-gutter:next-hunk "next")
    ("p" git-gutter:previous-hunk "previous")
    ("s" git-gutter:stage-hunk "stage")
    ("v" git-gutter:revert-hunk "revert")
    ("m" git-gutter:mark-hunk "mark")
    ;; TODO: pressing "o" twice shuld toggle popup off
    ("o" git-gutter:popup-hunk "popup" :toggle t))))

(let ((heads (append hydra-magit/heads-plist
		     hydra-git-gutter/heads-plist)))
  (setq hydra-magit/heads-plist heads))


;; (pretty-hydra-define hydra-git-timemachine ()
;;   ("Git Timemachine"
;;    (("t" git-timemachine "timemachine" :exit t)
;;     ("b" git-timemachine-blame "blame" :exit t)
;;     ("p" git-timemachine-show-previous-revision "back")
;;     ("n" git-timemachine-show-next-revision "forward"))))

;; (eval
;;  (macroexpand-all
;;   `(pretty-hydra-define hydra-git ()
;;      (,@(append hydra-magit/heads-plist
;; 		hydra-git-timemachine/heads-plist
;; 		hydra-git-gutter/heads-plist)))))

(defvar hydra-git/saved-configuration)
(use-package hydra
  :pretty-hydra
  (hydra-git
   (:color amaranth
    :post 
    (if debug-on-error (debug hydra-git/saved-configuration)
      (set-window-configuration hydra-git/saved-configuration)))
   ("Magit"
    (("g" magit-status "status" :exit t)
     ("c" (call-interactively
	   (if prefix-arg 'magit-commit 'magit-commit-create))
      "commit" :exit t))
    ""
    (("n" git-gutter:next-hunk "next")
     ("p" git-gutter:previous-hunk "previous"))
    "Hunk"
    (("s" git-gutter:stage-hunk "stage")
     ("v" git-gutter:revert-hunk "revert"))
    ""
    (;; TODO: pressing "o" twice shuld toggle popup off
     ("o" git-gutter:popup-hunk "popup" :toggle t)
     ("m" git-gutter:mark-hunk "mark"))
    "Git Timemachine"
    (("t" hydra-git-timemachine "timemachine" :exit t)
     ("b" git-timemachine-blame "blame" :exit t))))
  :config
  (add-function
   :around (symbol-function 'hydra-git/body)
   (lambda (f &rest args)
     (let ((hydra-git/saved-configuration
	    (current-window-configuration (selected-frame))))
       (apply f args)))))
#+end_src

** Magit

Magit is a Git interface for emacs. It helps tremendously with partial commits, rebase and history browsing.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :config
  (setq magit-save-repository-buffers nil)
  (setq magit-display-buffer-function
	'magit-display-buffer-same-window-except-diff-v1))
#+END_SRC

Make PR links clickable

#+begin_src emacs-lisp
(add-hook 'magit-process-mode-hook 'goto-address-mode)
#+end_src

** Git Timemachine

Git timemachine allows you to quickly review the history of a signle file

#+BEGIN_SRC emacs-lisp
(package-install 'git-timemachine)

(defhydra+ hydra-git ()
    "git-timemachine"
    ("t" git-timemachine))
#+END_SRC

#+END_SRC

** Git Gutter

#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :config
  (setq git-gutter:ask-p nil)
  (global-git-gutter-mode 1))
#+END_SRC

** Ediff

Ediff starts in the new frame by defualt. This change makes ediff reuse existing frame and restore window layout on exit.

#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC

*** Copy both buffers to C

#+begin_src emacs-lisp
(defun ediff-copy-both-to-C ()
    (interactive)
    (ediff-copy-diff ediff-current-difference nil 'C nil
    (concat
    (ediff-get-region-contents ediff-current-difference 'A ediff-control-buffer)
    (ediff-get-region-contents ediff-current-difference 'B ediff-control-buffer))))
(defun add-d-to-ediff-mode-map () (define-key ediff-mode-map "d" 'ediff-copy-both-to-C))
(add-hook 'ediff-keymap-setup-hook 'add-d-to-ediff-mode-map)
#+end_src

* Projects

Use projectile to traverse the files between projects.

#+BEGIN_SRC emacs-lisp
(package-install 'projectile)

;; Remove projectile shortcut which violates userspace key binding guidelines
(with-eval-after-load "projectile"
    (define-key projectile-mode-map (kbd "C-c p") nil))

;; By my own convention, globally accessible key-bindings live under C-x prefix.
(global-set-key (kbd "C-x p") 'projectile-command-map)

;; Enable
(projectile-mode 1)
#+END_SRC

Install =ag= to enable some of Projectile's functionality.

#+BEGIN_SRC emacs-lisp
(package-install 'ag)
#+END_SRC

Show file tree using dired sidebar:

#+BEGIN_SRC emacs-lisp
(use-package vscode-icon
    :ensure t
    :config
    ;; Apparently emacs can't resize images despite having been compiled
    ;; with imagemagic support.
    (advice-add 'vscode-icon-can-scale-image-p :override 'ignore))

(use-package dired-sidebar
    :bind (("C-x C-n" . dired-sidebar-toggle-sidebar))
    :requires vscode-icon
    :ensure t
    :commands (dired-sidebar-toggle-sidebar)
    :init
    (add-hook 'dired-sidebar-mode-hook
    (lambda ()
    (unless (file-remote-p default-directory)
    (auto-revert-mode))))
    :config

    (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
    (push 'rotate-windows dired-sidebar-toggle-hidden-commands)

    (setq dired-sidebar-subtree-line-prefix "__")
    (setq dired-sidebar-icon-scale 0.1)
    (setq dired-sidebar-theme 'vscode)
    (setq dired-sidebar-use-term-integration t)
    (setq dired-sidebar-use-custom-font t))
#+END_SRC

* Emacs Lisp

** Font lock

Add more font lock faces
#+begin_src emacs-lisp
(use-package morlock
  :ensure t
  :config
  (global-morlock-mode t))
#+end_src

Add more symbol highlights

#+begin_src emacs-lisp
#+end_src

** Paredit

Paredit helps keeps parentheses ballanced and provides a few useful commands for working with lisp code.

#+BEGIN_SRC emacs-lisp
(use-package paredit
    :config (add-hook 'emacs-lisp-mode-hook #'paredit-mode))
#+END_SRC

Use paredit in eval-expression mode

#+BEGIN_SRC emacs-lisp
(add-hook 'eval-expression-minibuffer-setup-hook #'paredit-mode)
#+END_SRC

Custom keybindings.

#+begin_src emacs-lisp
(defhydra hydra-paredit (paredit-mode-map ""  :exit t)
  "Paredit"
  ("M-N" paredit-add-to-next-list)
  ("M-P" paredit-add-to-previous-list)
  ;; ("M-SPC" just-one-space)
  ;; ;; (define-key paredit-mode-map (kbd "M-SPC") 'nil)
  ;; (skip-chars-backward "\r\n\s\t")
  ;; (when (prog1 (looking-at "[\r\n\s\t]")
  ;; 	   (just-one-space -1))
  ;;   (just-one-space 0)))
  ("C-k" paredit-kill)
  ("C-M-k" kill-sexp)
  ("M-U" paredit-convolute-sexp)
  ("M-H" paredit-backward-slurp-sexp)
  ("M-L" paredit-forward-slurp-sexp)
  ("M-K" paredit-forward-barf-sexp)
  ("C-M-n" paredit-forward-up)
  ("M-r" paredit-raise-sexp)
  ("M-s" paredit-splice-sexp-killing-backward)
  ("M-s" paredit-splice-sexp-killing-backward)
  ("C-M-y" paredit-yank-pop))

(use-package paredit)
#+end_src

Kill whitespace with C-K

#+begin_src emacs-lisp
(with-eval-after-load 'paredit
  (defun paredit-kill-line-whitepace (&optional arg)
    (let ((start (point)))
      (or (= 0 (skip-syntax-forward " "))
          (kill-region start (point)))))
  (advice-add #'paredit-kill :before-while
              #'paredit-kill-line-whitepace))
#+end_src

** Macro expansion

#+BEGIN_SRC emacs-lisp
(use-package macrostep
    :bind ("C-c C-e" . macrostep-expand))
#+END_SRC

* Javascript

Set up tools for working with JavaScript code.

** JS Mode

I use simple JS mode for now beacuse it's easier to get into when something goes wrong.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "js"
    (setq-default js-indent-level 2))
#+END_SRC

Enable automatic pairing and alignment of parentheses and braces:

#+BEGIN_SRC emacs-lisp
(add-hook 'js-mode-hook 'electric-pair-local-mode)
(add-hook 'js-mode-hook 'electric-indent-local-mode)
#+END_SRC

** Custom keybindings

I often need to sort lines in alphabetical order when working with Javascript.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "js"
    (define-key js-mode-map (kbd "C-c s") 'sort-lines))
#+END_SRC

** Formatting

Prettier-emacs automatically formats code on save.

#+BEGIN_SRC emacs-lisp
(package-install 'prettier-js)

(add-hook 'js-mode-hook 'prettier-js-mode)
#+END_SRC

Look up prettier executable in node_modules

#+BEGIN_SRC emacs-lisp
(package-install 'add-node-modules-path)

(add-hook 'prettier-js-mode-hook 'add-node-modules-path)
#+END_SRC

** Linter

Flycheck will use static analysis tools and highlight errors in the buffer.

#+BEGIN_SRC emacs-lisp
(package-install 'flycheck)

(add-hook 'js-mode-hook
    (lambda ()
    (flycheck-mode 1)
    ;; Unless explicitly told flycheck can choose other
    ;; checker which will mess up the chain setup below
    (setq-local flycheck-checker 'javascript-eslint)))

(with-eval-after-load "js"
    (define-key js-mode-map (kbd "M-p") 'flycheck-previous-error)
    (define-key js-mode-map (kbd "M-n") 'flycheck-next-error))
#+END_SRC

* Typescript

Typescript is a language that compiles to javascript.

Typescript support in emacs is pretty solid thanks to [TypeScript Mode](https://github.com/ananthakumaran/typescript.el), which enables syntax highlighting and indentation, and [Typescript Interactive Development Environment](https://github.com/ananthakumaran/tide) which provides integration with typescript server.

** Basic Editing Support

Install typescript mode:

#+BEGIN_SRC emacs-lisp
(package-install 'typescript-mode)

;; Add .tsx to the list of extensions associated with typescript-mode
(add-to-list 'auto-mode-alist
    '("\\.tsx\\'" . typescript-mode))
#+END_SRC

Change default indentation level:

#+BEGIN_SRC emacs-lisp
(setq-default typescript-indent-level 2)
#+END_SRC

Enable auto-pairing:

#+BEGIN_SRC emacs-lisp
(add-hook 'typescript-mode-hook 'electric-pair-local-mode)
(add-hook 'typescript-mode-hook 'electric-indent-local-mode)
#+END_SRC

Fix comment continuation with <kbd>M-j</kbd>

Pressing <kbd>M-j</kbd> while inside a multiline comment allows you to insert a line break into the comment block. I find that `c-indent-new-comment-line` does better job than `indent-new-comment-line` in `js-mode`.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "typescript-mode"
    (define-key typescript-mode-map (kbd "M-j") 'c-indent-new-comment-line))
#+END_SRC

** TypeScript Server integraiton

Setup lsp-mode

#+begin_src emacs-lisp
(use-package lsp-mode
  :hook ((typescript-mode . lsp)))
#+end_src

Setup TIDE:

#+BEGIN_SRC emacs-lisp
(package-install 'tide)

(with-eval-after-load "flycheck"
    (flycheck-def-config-file-var typescript-tslint-typecheck-tsconfig
    typescript-tslint "tsconfig.json"
    :safe #'stringp
    :package-version '(flycheck . "27"))

    (flycheck-define-checker typescript-tslint
    "TypeScript style checker using TSLint.

Note that this syntax checker is not used if
`flycheck-typescript-tslint-config' is nil or refers to a
non-existing file.

See URL `https://github.com/palantir/tslint'."
    :command ("tslint" "--format" "json"
    (config-file "--config" flycheck-typescript-tslint-config)
    (config-file "--project" typescript-tslint-typecheck-tsconfig)
    (option "--rules-dir" flycheck-typescript-tslint-rulesdir)
    (eval flycheck-tslint-args)
    source-original)
    :error-parser flycheck-parse-tslint
    :modes (typescript-mode)))

;; Working setup taken directly from TIDE documentaiton
(defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (flycheck-mode +1)
    ;; (add-to-list 'flycheck-checkers 'typescript-tslint-typecheck)
    ;; (flycheck-add-next-checker 'typescript-tide 'typescript-tslint-typecheck)
    ;; (add-to-list 'flycheck-disabled-checkers 'typescript-tslint)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (tide-hl-identifier-mode +1))

;; Disable tide autoformat if prettier is available
(remove-hook 'before-save-hook 'tide-format-before-save)

(add-hook 'typescript-mode-hook 'setup-tide-mode)
#+END_SRC

Enable completion support:

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "typescript-mode"
    (add-hook 'typescript-mode-hook 'company-mode)
    (define-key typescript-mode-map (kbd "TAB") 'company-indent-or-complete-common))
#+END_SRC

Enable flycheck in typescript buffers:

#+BEGIN_SRC emacs-lisp
;; Set up flycheck keybindings
(with-eval-after-load "tide"
    (define-key tide-mode-map (kbd "M-p") 'flycheck-previous-error)
    (define-key tide-mode-map (kbd "M-n") 'flycheck-next-error))
#+END_SRC

** Formatting

Although TIDE provides formatting capabilities powered by typescript executables, they do not handle formatting as well as ~prettier~.

#+BEGIN_SRC emacs-lisp
(package-install 'prettier-js)

(add-hook 'typescript-mode-hook 'prettier-js-mode)
#+END_SRC

** Auto fix

Some tslint errors are annoying to fix manually.

#+BEGIN_SRC emacs-lisp
(defun tslint-fix-and-revert ()
    (interactive)
    (when (or (not (buffer-modified-p))
    ;; Ask for confirmation when reverting modified buffer
    (yes-or-no-p (format "Revert buffer from file %s? "
    (buffer-file-name))))
    (shell-command (concat "tslint --fix " (buffer-file-name)))
    (revert-buffer nil 'noconfirm)))

(with-eval-after-load "typescript-mode"
    (define-key typescript-mode-map (kbd "C-c C-r") 'tslint-fix-and-revert))
#+END_SRC

** Code Folding

#+BEGIN_SRC emacs-lisp
(add-hook 'typescript-mode-hook 'hs-minor-mode)

(with-eval-after-load "typescript-mode"
    (define-key typescript-mode-map (kbd "C-c C-f") 'hs-toggle-hiding))
#+END_SRC

** Compilation

Colorize tsc messages in ~compilation-mode~:

#+BEGIN_SRC emacs-lisp
(require 'ansi-color)
(defun colorize-compilation-buffer ()
    (ansi-color-apply-on-region compilation-filter-start (point-max)))
(add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+END_SRC

Display compilation below all windows

#+begin_src emacs-lisp

#+end_src


* GraphQL

Firstly we neeed to install graphql-mode for syntax highlighting

#+begin_src emacs-lisp
(use-package graphql-mode
  :ensure t)

(use-package lsp-mode
  ;; :config
  ;; (lsp-register-client
  ;;  (make-lsp-client
  ;;  :new-connection
  ;;  (lsp-tcp-connection
  ;;   (lambda (port)
  ;;     `("graphql-lsp" "server" "-m" "stream" "-p"
  ;; 	,(number-to-string port))))
  ;;  :major-modes '(graphql-mode)
  ;;  :initialization-options (lambda () `())
  ;;  :server-id 'graphql))
  ;; (add-to-list 'lsp-language-id-configuration
  ;; 	       '(graphql-mode . "graphql"))
  )
#+end_src

Then we can edit GraphQL source blocks inside org-mode buffer

#+begin_src emacs-lisp
(use-package ob-graphql)
#+end_src

* CSS

Using web-mode for CSS files primarily because it supports comment-continuation with ~M-j~.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist
    '("\\.css\\'" . web-mode))
#+END_SRC

Adjust base indentaiton level:

#+BEGIN_SRC emacs-lisp
(setq web-mode-css-indent-offset 2)
#+END_SRC

Disable ~hl-line-mode~ which conflicts with highlighted color literals.

#+BEGIN_SRC emacs-lisp
(defun disable-hl-line-mode ()
    (hl-line-mode -1))

(add-hook 'css-mode-hook 'disable-hl-line-mode)
#+END_SRC

* Python

Enable electric-pair-mode to surround seleciton with parentheses:

#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook 'electric-pair-local-mode)
#+END_SRC

** Elpy

I use Elpy for go-to-definition functionality in python source files.

#+BEGIN_SRC emacs-lisp
(use-package elpy
    :config
    (elpy-enable))
#+END_SRC

* Markdown

Install markdown mode for syntax highlighting.

#+BEGIN_SRC emacs-lisp
(package-install 'markdown-mode)
#+END_SRC

Enable syntax highlighting in code blocks.

#+BEGIN_SRC emacs-lisp
(setq-default markdown-fontify-code-blocks-natively t)
#+END_SRC

Use spaces instead of tabs

#+BEGIN_SRC emacs-lisp
(add-hook 'markdown-mode-hook (lambda () (setq indent-tabs-mode nil)))
#+END_SRC

Enable visual-fill-column and visual-line modes for markdown files.

Visual-fill-colums ensures long lines are broken up at regular intervals to make text more readable.

Unlike auto-fill-mode it does not alter file contents.

Visual-line-mode ensures lines get broken at word boundaries.

#+BEGIN_SRC emacs-lisp
(package-install 'visual-fill-column)

(with-eval-after-load 'markdown-mode
    (add-hook 'markdown-mode-hook 'visual-fill-column-mode)
    (add-hook 'markdown-mode-hook 'visual-line-mode))
#+END_SRC

Enable spell checking.

#+BEGIN_SRC emacs-lisp
(setq ispell-really-aspell nil
    ispell-really-hunspell t
    ispell-program-name "hunspell")

(setq ispell-local-dictionary-alist
    '((nil "[[:alpha:]]" "[^[:alpha:]]" "[0-9]" t ("-d" "en_US,ru_RU") nil utf-8)))

(add-hook 'markdown-mode-hook 'flyspell-mode)
#+END_SRC

* Clojure

Install clojure-mode

#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
    :ensure t)
#+END_SRC

Use Lispy to navigate clojure code

#+BEGIN_SRC emacs-lisp
(use-package lispy
    :ensure t
    :hook (clojure-mode . lispy-mode))
#+END_SRC

Add userful clojure commands

#+BEGIN_SRC emacs-lisp
(use-package cider
    :ensure t
    :hook (clojure-mode . cider-mode)
    :config
    (setq cider-clojure-cli-global-options "-R:fig"))
#+END_SRC

* OCaml

Install tuareg-mode - a language support for ocaml.

#+BEGIN_SRC emacs-lisp
(use-package tuareg)
#+END_SRC

Install ocp-indent for better indentation.

#+BEGIN_SRC emacs-lisp
(use-package ocp-indent
    :if (executable-find "ocp-indent")
    :hook (tuareg-mode . ocp-setup-indent))
#+END_SRC

Install Merlin for language server integraiton:

#+BEGIN_SRC emacs-lisp
(use-package merlin
    :hook (tuareg-mode . merlin-mode)
    :config
    ;; Enable jump-to-definition functionality when merlin mode is active
    (defun install-merlin-xref-backend ()
    (add-hook 'xref-backend-functions 'merlin-xref-backend nil t))
    (add-hook 'merlin-mode-hook 'install-merlin-xref-backend))

;; Install merlin-eldoc for minibuffer tooltips
(use-package merlin-eldoc
    :hook (merlin-mode . merlin-eldoc-setup))
#+END_SRC

Enable autocompletion with company-mode:

#+BEGIN_SRC emacs-lisp
(use-package company
    :requires merlin
    :hook (tuareg-mode . company-mode))
#+END_SRC

Enable syntax checking with flycheck-ocaml:

#+BEGIN_SRC emacs-lisp
(use-package flycheck-ocaml
    :requires (flycheck merlin)
    :hook (tuareg-mode . flycheck-ocaml-setup))
#+END_SRC

Install Utop for REPL.

#+BEGIN_SRC emacs-lisp
(use-package utop
    :if (executable-find "opam")
    :hook (tuareg-mode . utop-minor-mode)
    :config
    (setq utop-command "opam config exec -- utop -emacs"))
#+END_SRC

* Rust

Use ~rust-mode~ for syntax highlighting.

#+BEGIN_SRC emacs-lisp
(use-package rust-mode)
#+END_SRC

Use ~racer~ for autocompletion in rust files

#+BEGIN_SRC emacs-lisp
(use-package racer
    :requires company
    :hook (rust-mode . racer-mode))
#+END_SRC

* REST Client

Useful for testing REST api.

#+BEGIN_SRC emacs-lisp
(package-install 'restclient)

(defun configure-restclient ()
    (setq tab-width 2))

(with-eval-after-load "restclient"
    (add-hook 'restclient-mode-hook 'configure-restclient))
#+END_SRC

* XML

** Folding

#+begin_src emacs-lisp
(defun hs-toggle-block ()
    "Toggle hideshow all."
    (interactive)
    (if (hs-already-hidden-p) (hs-show-block) (hs-hide-block)))

(defun hs-toggle-level ()
    "Toggle hideshow all."
    (interactive)
    (save-excursion
    (let (minp maxp (all-shown t))
    (when (hs-find-block-beginning)
    (setq minp (1+ (point)))
    (funcall hs-forward-sexp-func 1)
    (setq maxp (1- (point)))
    (goto-char minp))
    (while (progn
    (forward-comment (buffer-size))
    (and (< (point) maxp)
    (re-search-forward hs-block-start-regexp maxp t)))
    (when (save-match-data (not (nth 8 (syntax-ppss)))) ; not inside comments or strings
    (setq all-shown (and all-shown (not (hs-already-hidden-p))))
    (hs-show-block)))
    (when all-shown
    (goto-char minp)
    (hs-hide-level-recursive 1 minp maxp)))))

(use-package hideshow
    :bind
    ("M-ESC" . hs-toggle-block)
    ("C-M-{" . hs-hide-all)
    ("C-M-]" . hs-toggle-level)
    ("C-M-}" . hs-show-all)
    :config
    (add-hook 'nxml-mode 'hs-minor-mode)
    (add-to-list 'hs-special-modes-alist
    '(nxml-mode
    "<!--\\|<[^/>]*[^/]>"
    "-->\\|</[^/>]*[^/]>"

    "<!--"
    sgml-skip-tag-forward
    nil)))
#+end_src

*** Origami

#+begin_src emacs-lisp
(use-package origami
  :bind ("M-ESC" . #'origami-toggle-node))
#+end_src

* Bolt

Bolt is a language for schema modeleing in firebase.

#+BEGIN_SRC emacs-lisp
(quelpa '(bolt-mode
    :repo "mpontus/bolt-mode"
    :fetcher github))
#+END_SRC

* Terraform

Enable syntax highlighting for terraform mode

#+BEGIN_SRC emacs-lisp
(use-package terraform-mode)

(use-package hcl-mode
    :quelpa
    (hcl-mode :fetcher github :repo "mpontus/emacs-hcl-mode"))
#+END_SRC

*** LSP

Enable autocompletion using LSP

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
    :hook terraform-mode
    :config
    (add-to-list 'lsp-language-id-configuration '(terraform-mode . "terraform"))
    (lsp-register-client
    (make-lsp-client :new-connection (lsp-stdio-connection '("~/terraform-ls" "serve"))
    :major-modes '(terraform-mode)
    :server-id 'terraform-ls)))

#+END_SRC

* Ledger

#+begin_src emacs-lisp
(use-package ledger-mode
    :init
    (setq ledger-clear-whole-transactions t)
    :mode "\\.dat\\'")

(with-eval-after-load 'ledger-mode
    (define-key ledger-mode-map (kbd "M-RET") #'newline-and-indent))
#+end_src

Add keybinding to easily open a ledger file

#+begin_src emacs-lisp
(defun find-ledger-file ()
    (interactive)
    (pop-to-buffer (find-file-noselect "~/ledger.dat") nil))

(define-key help-map (kbd "l") #'find-ledger-file)
#+end_src

In order not to have to worry about formatting as I'm editing the ledger file, I add a format hook on save.

#+begin_src emacs-lisp
(define-minor-mode ledger-format-on-save-mode
    "Format ledger buffer on save" nil nil nil
    (if ledger-format-on-save-mode
    (add-hook 'before-save-hook #'ledger-mode-clean-buffer nil t)
    (remove-hook 'before-save-hook #'ledger-mode-clean-buffer t)))

(add-hook 'ledger-mode-hook #'ledger-format-on-save-mode)
(add-hook 'ledger-mode-hook #'ledger-format-on-save-mode)
#+end_src

#+CAPTION: Hotkeys
|--------------+------------------------|
| key sequence | command                |
|--------------+------------------------|
| C-c C-a      | ledger-add-transaction |
| C-c C-o C-r  | ledger-report          |
|--------------+------------------------|

*** COMMENT Reports


#+begin_src emacs-lisp
(use-package transient)			;

(defconst ledger-commands
  ["Commands"
   [("a" "account" keyboard-quit)]
   [("ba" "balance" keyboard-quit)]
   [("bu" "budget" keyboard-quit)]
   [("cl" "cleared" keyboard-quit)]
   [("com" "commodities" keyboard-quit)]
   [("con" "convert" keyboard-quit)]
   [("cs" "csv" keyboard-quit)]
   [("en" "entry" keyboard-quit)]
   [("em" "emacs" keyboard-quit)]
   [("eq" "equity" keyboard-quit)]
   [("pa" "payees" keyboard-quit)]
   [("pricem" "pricemap" keyboard-quit)]
   [("prices" "prices" keyboard-quit)]
   [("priced" "pricedb" keyboard-quit)]
   [("prin" "print" keyboard-quit)]
   [("pu" "push" keyboard-quit)]
   [("po" "pop" keyboard-quit)]
   [("r" "register" keyboard-quit)]
   [("ser" "server" keyboard-quit)]
   [("sel" "select" keyboard-quit)]
   [("so" "source" keyboard-quit)]
   [("st" "stats" keyboard-quit)]
   [("x" "xml" keyboard-quit)]
   ])


(transient-define-prefix
  ledger-report-register (&optional report-query)
  ""
  ["Options"
   ("-A" "Show the running average, rather" "--average")
   ("-c" "Don't show postings beyond the" "--current")
   ("-X" "enter commodity" "--exchange=")
   ("-G" "Show any gains (or losses) in" "--gain")
   ("--head" "Only show the top number post" "--head=")
   ("-H" "" "--historical")
   ("--invert" "Invert the value of amounts" "--invert")
   ("-V" "Show current market values for" "--market")
   ("-p" "--period" "--period=")
   ("-r" "Show postings that are related" "--related")
   ("-S" "enter value-expression" "--sort=")
   ("--tail" "Only show the last number postâ€" "--tail=")
   ("-U" "" "--uncleared")
   ("-P" "Group postings by common payee" "--by-payee")
   ("-D" "Group postings by day." "--daily")
   ("-W" "Group postings by week" "--weekly")
   ("--start-of-week" "enter day" "--start-of-week=")
   ("-M" "Group postings by month." "--monthly")
   ("--quarterly" "Group postings by fiscal quarâ€" "--quarterly")
   ("-Y" "Group postings by year." "--yearly")
   ("--days-of-week" "Group postings by the day of the" "--days-of-week")
   ("-s" "Group all postings together." "--subtotal")]
  ["Commands"
   ()])


(transient-define-prefix ledger-report ()
  "Run ledger report"
  ["Options"
   ("-r" "Do not treat root commits as boundaries" "--root")]
  ["Commands"
   [("a" "account" keyboard-quit)]
   [("ba" "balance" keyboard-quit)]
   [("bu" "budget" keyboard-quit)]
   [("cl" "cleared" keyboard-quit)]
   [("com" "commodities" keyboard-quit)]
   [("con" "convert" keyboard-quit)]
   [("cs" "csv" keyboard-quit)]
   [("en" "entry" keyboard-quit)]
   [("em" "emacs" keyboard-quit)]
   [("eq" "equity" keyboard-quit)]
   [("pa" "payees" keyboard-quit)]
   [("pricem" "pricemap" keyboard-quit)]
   [("prices" "prices" keyboard-quit)]
   [("priced" "pricedb" keyboard-quit)]
   [("prin" "print" keyboard-quit)]
   [("pu" "push" keyboard-quit)]
   [("po" "pop" keyboard-quit)]
   [("r" "register" keyboard-quit)]
   [("ser" "server" keyboard-quit)]
   [("sel" "select" keyboard-quit)]
   [("so" "source" keyboard-quit)]
   [("st" "stats" keyboard-quit)]
   [("x" "xml" keyboard-quit)]
   ])
#+end_src

*  Docker
#+begin_src emacs-lisp
(defun ivy-docker-compose-logs (args)
  "Completing read for `docker-compose-logs'"
  (interactive (list (transient-args transient-current-command)))
  (let ((enable-recursive-minibuffers t))
    (ivy-read "Service: " (docker-compose-services)
              :require-match t
	      :action
	      (lambda (service)
		(docker-compose-run-docker-compose-async
		 "logs" args (list service)))
              :caller 'ivy-docker-compose-logs)))

(use-package docker
  :bind (("C-c d" . docker))
  :config
  (transient-append-suffix 'docker-compose-logs
    'docker-compose-run-action-for-one-service
    '("I" "Logs (Ivy)" ivy-docker-compose-logs))
  ;; (add-to-list 'display-buffer-alist
  ;;   '("^\\*docker-compose logs .*\\*$" display-buffer-same-window))
  )

(use-package docker-tramp)


#+end_src

* NixOS

Install nix-mode for editing ~.nix~ files

#+begin_src emacs-lisp
(use-package nix-mode)
#+end_src

Use rnix language server for advanced editing features.

#+begin_src emacs-lisp
;; (defalias 'lsp--nix-dependency-path #'lsp--system-path)
(cl-defun lsp--nix-dependency-path (&key path &allow-other-keys)
  "Return npm dependency PATH for PACKAGE."
  (lsp--system-path path))

(cl-defun lsp--nix-dependency-install (callback error-callback &key package &allow-other-keys)
  (if-let ((nix-env-binary (executable-find "nix-env")))
      (lsp-async-start-process callback
                               error-callback
                               nix-env-binary
                               "-i"
			       package)
    (lsp-log "Unable to install %s via `nix-env' because it is not present" package)
    nil))

(use-package lsp-mode
  :config
  (add-to-list 'lsp-language-id-configuration '(nix-mode . "nix"))
  (plist-put lsp-deps-providers :nix
	     (list :path #'lsp--nix-dependency-path
                   :install #'lsp--nix-dependency-install))
  (lsp-dependency 'rnix-lsp
                  ;; '(:system "rnix-lsp")
                  '(:nix :package "rnix-lsp"
			 :path "rnix-lsp"))
  (lsp-register-client
   (make-lsp-client :new-connection
		    (lsp-stdio-connection
		     (lambda ()
		       (list (lsp-package-path 'rnix-lsp))))
                    :major-modes '(nix-mode)
		    :remote? t
                    :server-id 'nix
		    :download-server-fn
		    (lambda (_client callback error-callback _update?)
                      (lsp-package-ensure 'rnix-lsp callback error-callback)))))
#+end_src
